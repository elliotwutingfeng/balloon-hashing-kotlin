/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package balloon.hashing.kotlin

import java.io.ByteArrayOutputStream
import java.math.BigInteger
import java.security.MessageDigest
import java.util.HexFormat
import java.util.stream.IntStream

/**
 * Standard cryptographic hash functions.
 *
 * @property acronym Shorthand form of cryptographic hash function name.
 * @constructor Creates an empty Hash type.
 */
enum class HashType(val acronym: String) {
    MD2("MD2"),
    MD5("MD5"),
    SHA1("SHA-1"),
    SHA224("SHA-224"),
    SHA256("SHA-256"),
    SHA384("SHA-384"),
    SHA512("SHA-512"),
    SHA512_224("SHA-512/224"),
    SHA512_256("SHA-512/256"),
    SHA3_224("SHA3-224"),
    SHA3_256("SHA3-256"),
    SHA3_384("SHA3-384"),
    SHA3_512("SHA3-512")
}

/**
 * Balloon hashing class for hashing a password.
 *
 * @property hashType Cryptographic hashing algorithm to use.
 * @constructor Creates an empty Balloon hashing.
 */
class BalloonHashing(private val hashType: HashType) {
    /**
     * Decode a hex string to its byte array representation.
     *
     * @return A series of bytes representing the hex string.
     */
    private fun String.decodeHex(): ByteArray {
        return chunked(2).map { it.toInt(16).toByte() }.toByteArray()
    }

    /**
     * Concatenates an arbitrary number of byte arrays.
     *
     * @param arrays Byte arrays to concatenate.
     * @return Concatenated form of [arrays].
     */
    private fun concat(vararg arrays: ByteArray): ByteArray {
        val out = ByteArrayOutputStream()
        arrays.forEach { out.write(it) }
        return out.toByteArray()
    }

    /**
     * Divide [buffer] by [divisor] and returns the remainder.
     *
     * @param buffer Byte array representation of a number in little endian.
     * @param divisor Number to divide [buffer] by.
     * @return Remainder of [buffer] divided by [divisor].
     */
    private fun byteArrayMod(buffer: ByteArray, divisor: Int): Int {
        // Check if MSB of buffer's MSB is set, if so
        // add byteArrayOf(0) to keep the sign positive
        val reversedBuffer = buffer.reversed().toByteArray()
        val m =
                BigInteger(
                        (if (reversedBuffer[0].toInt() and 128 > 0) byteArrayOf(0)
                        else byteArrayOf()) + reversedBuffer
                )
        return m.mod(divisor.toBigInteger()).toInt()
    }

    /**
     * Convert number [data] to byte array in little endian.
     *
     * @param data Number to convert.
     * @param size Byte size. Defaults to 8.
     * @return Byte array representation of number [data] in little endian.
     */
    private fun numberToByteArray(data: Number, size: UInt = 8u): ByteArray =
            ByteArray(size.toInt()) { i -> (data.toLong() shr (i * 8)).toByte() }

    /**
     * Concatenate all the arguments and hash the result using the algorithm specified by [hashType]
     * .
     *
     * @param args Arguments to concatenate.
     * @return The hashed string.
     */
    private fun hashFunc(vararg args: ByteArray): ByteArray {
        val t: ByteArray = concat(*args)
        val md = MessageDigest.getInstance(hashType.acronym)
        return md.digest(t)
    }

    /**
     * First step of the algorithm. Fill up a buffer with pseudorandom bytes derived from the
     * password and salt by computing repeatedly the hash function on a combination of the password
     * and the previous hash.
     *
     * @param buf A list of hashes as bytes.
     * @param cnt Used in a security proof (read the paper).
     * @param spaceCost The size of the buffer.
     * @return Counter used in a security proof (read the paper).
     */
    private fun expand(buf: ArrayList<ByteArray>, cnt: UInt, spaceCost: UInt): UInt {
        var newcnt = cnt
        for (s in 1 until spaceCost.toInt()) {
            buf.add(hashFunc(numberToByteArray(newcnt.toInt()), buf[s - 1]))
            newcnt += 1u
        }
        return newcnt
    }

    /**
     * Second step of the algorithm. Mix [timeCost] number of times the pseudorandom bytes in the
     * buffer. At each step in the for loop, update the nth block to be the hash of the n-1th block,
     * the nth block, and [delta] other blocks chosen at random from the buffer [buf].
     *
     * @param buf A list of hashes as bytes.
     * @param cnt Used in a security proof (read the paper).
     * @param delta Number of random blocks to mix with.
     * @param salt A user defined random value for security.
     * @param spaceCost The size of the buffer.
     * @param timeCost Number of rounds to mix.
     */
    private fun mix(
            buf: ArrayList<ByteArray>,
            cnt: UInt,
            delta: UInt,
            salt: ByteArray,
            spaceCost: UInt,
            timeCost: UInt
    ) {
        var newcnt = cnt
        for (t in 0 until timeCost.toInt()) {
            for (s in 0 until spaceCost.toInt()) {
                buf[s] =
                        hashFunc(
                                numberToByteArray(newcnt.toInt()),
                                if (s == 0) extract(buf) else buf[s - 1],
                                buf[s]
                        )
                newcnt += 1u
                for (i in 0 until delta.toInt()) {
                    val idxBlock =
                            hashFunc(
                                    numberToByteArray(t),
                                    numberToByteArray(s),
                                    numberToByteArray(i)
                            )
                    val other =
                            byteArrayMod(
                                    hashFunc(numberToByteArray(newcnt.toInt()), salt, idxBlock),
                                    spaceCost.toInt()
                            )
                    newcnt += 1u
                    buf[s] = hashFunc(numberToByteArray(newcnt.toInt()), buf[s], buf[other])
                    newcnt += 1u
                }
            }
        }
    }

    /**
     * Final step. Return the last value in the buffer.
     *
     * @param buf A list of hashes as bytes.
     * @return Last value of the buffer as bytes.
     */
    private fun extract(buf: ArrayList<ByteArray>): ByteArray {
        return buf.last()
    }

    /**
     * Main function that collects all the substeps. As previously mentioned, first [expand], then
     * [mix], and finally [extract]. Note the result is returned as bytes, for a more friendly
     * function with default values that returns a hex string, see the function [balloonHash].
     *
     * @param password The main string to hash.
     * @param salt A user defined random value for security.
     * @param spaceCost The size of the buffer.
     * @param timeCost Number of rounds to mix.
     * @param delta Number of random blocks to mix with. Defaults to 3.
     * @return A series of bytes, the hash.
     */
    fun balloon(
            password: String,
            salt: String,
            spaceCost: UInt,
            timeCost: UInt,
            delta: UInt = 3u
    ): ByteArray {
        return _balloon(password, salt.toByteArray(), spaceCost, timeCost, delta)
    }

    /**
     * For internal use. Implements steps outlined in [balloon].
     *
     * @param password The main string to hash.
     * @param salt A user defined random value for security.
     * @param spaceCost The size of the buffer.
     * @param timeCost Number of rounds to mix.
     * @param delta Number of random blocks to mix with. Defaults to 3.
     * @return A series of bytes, the hash.
     */
    private fun _balloon(
            password: String,
            salt: ByteArray,
            spaceCost: UInt,
            timeCost: UInt,
            delta: UInt = 3u
    ): ByteArray {
        val buf = ArrayList<ByteArray>()
        buf.add(hashFunc(numberToByteArray(0), password.toByteArray(), salt))
        val cnt = expand(buf, 1u, spaceCost)
        mix(buf, cnt, delta, salt, spaceCost, timeCost)
        return extract(buf)
    }

    /**
     * A more friendly client function that just takes a [password] and a [salt] and outputs the
     * hash as a hex string.
     *
     * @param password The main string to hash.
     * @param salt A user defined random value for security.
     * @return The hash as hex.
     */
    fun balloonHash(password: String, salt: String): String {
        val delta = 4u
        val timeCost = 20u
        val spaceCost = 16u
        return HexFormat.of().formatHex(balloon(password, salt, spaceCost, timeCost, delta = delta))
    }

    /**
     * M-core variant of the Balloon hashing algorithm. Note the result is returned as bytes, for a
     * more friendly function with default values that returns a hex string, see the function
     * [balloonMHash].
     *
     * @param password The main string to hash.
     * @param salt A user defined random value for security.
     * @param spaceCost The size of the buffer.
     * @param timeCost Number of rounds to mix.
     * @param parallelCost Number of concurrent instances.
     * @param delta Number of random blocks to mix with. Defaults to 3.
     * @return A series of bytes, the hash.
     */
    fun balloonM(
            password: String,
            salt: String,
            spaceCost: UInt,
            timeCost: UInt,
            parallelCost: UInt,
            delta: UInt = 3u
    ): ByteArray {
        check(parallelCost >= 1u) { "parallelCost must have minimum value of 1" }
        val output =
                IntStream.range(0, parallelCost.toInt())
                        .parallel()
                        .mapToObj { p ->
                            run {
                                val parallelSalt = salt.toByteArray() + numberToByteArray(p + 1)
                                _balloon(password, parallelSalt, spaceCost, timeCost, delta)
                            }
                        }
                        .reduce { a, b ->
                            run {
                                val buf = ByteArray(a.size)
                                for (i in 0 until a.size) {
                                    buf[i] = (a[i].toUByte() xor b[i].toUByte()).toByte()
                                }
                                buf
                            }
                        }
                        .orElseThrow { IllegalArgumentException() }

        return hashFunc(password.toByteArray(), salt.toByteArray(), output)
    }

    /**
     * A more friendly client function that just takes a [password] and a [salt] and outputs the
     * hash as a hex string. This uses the M-core variant of the Balloon hashing algorithm.
     *
     * @param password The main string to hash.
     * @param salt A user defined random value for security.
     * @return The hash as hex.
     */
    fun balloonMHash(password: String, salt: String): String {
        val delta = 4u
        val timeCost = 20u
        val spaceCost = 16u
        val parallelCost = 4u
        return HexFormat.of()
                .formatHex(
                        balloonM(password, salt, spaceCost, timeCost, parallelCost, delta = delta)
                )
    }

    /**
     * Verify that [hash] matches [password] when hashed with [salt], [spaceCost], [timeCost], and
     * [delta].
     *
     * @param hash The hash to check against.
     * @param password The password to verify.
     * @param salt A user defined random value for security.
     * @param spaceCost The size of the buffer.
     * @param timeCost Number of rounds to mix.
     * @param delta Number of random blocks to mix with. Defaults to 3.
     * @return true if password matches hash, otherwise false.
     */
    fun verify(
            hash: String,
            password: String,
            salt: String,
            spaceCost: UInt,
            timeCost: UInt,
            delta: UInt = 3u
    ): Boolean {
        check(hash.length % 2 == 0) { "Must have an even length" }
        return MessageDigest.isEqual(
                balloon(password, salt, spaceCost, timeCost, delta),
                hash.decodeHex()
        )
    }

    /**
     * Verify that [hash] matches [password] when hashed with [salt], [spaceCost], [timeCost],
     * [parallel cost], and [delta]. This uses the M-core variant of the Balloon hashing algorithm.
     *
     * @param hash The hash to check against.
     * @param password The password to verify.
     * @param salt A user defined random value for security.
     * @param spaceCost The size of the buffer.
     * @param timeCost Number of rounds to mix.
     * @param parallelCost Number of concurrent instances.
     * @param delta Number of random blocks to mix with. Defaults to 3.
     * @return true if password matches hash, otherwise false.
     */
    fun verifyM(
            hash: String,
            password: String,
            salt: String,
            spaceCost: UInt,
            timeCost: UInt,
            parallelCost: UInt,
            delta: UInt = 3u
    ): Boolean {
        check(parallelCost >= 1u) { "parallelCost must have minimum value of 1" }
        check(hash.length % 2 == 0) { "Must have an even length" }
        return MessageDigest.isEqual(
                balloonM(password, salt, spaceCost, timeCost, parallelCost, delta),
                hash.decodeHex()
        )
    }
}
