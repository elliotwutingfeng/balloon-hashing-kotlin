/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package balloon.hashing.kotlin

import java.io.ByteArrayOutputStream
import java.math.BigInteger
import java.security.MessageDigest
import java.util.HexFormat
import java.util.stream.IntStream;

/**
 * Standard cryptographic hash functions.
 *
 * @property acronym Shorthand form of cryptographic hash function name.
 * @constructor Creates an empty Hash type.
 */
enum class HashType(val acronym: String) {
    MD5("MD5"), SHA1("SHA-1"), SHA224("SHA-224"), SHA256("SHA-256"), SHA384("SHA-384"), SHA512("SHA-512")
}

/**
 * Balloon hashing class for hashing a password.
 *
 * @property hashType Cryptographic hashing algorithm to use.
 * @constructor Creates an empty Balloon hashing.
 */
class BalloonHashing(private val hashType: HashType) {
    /**
     * Decode a hex string to its byte array representation.
     *
     * @return A series of bytes representing the hex string.
     */
    private fun String.decodeHex(): ByteArray {
        return chunked(2).map { it.toInt(16).toByte() }.toByteArray()
    }

    /**
     * Concatenates an arbitrary number of byte arrays.
     *
     * @param arrays Byte arrays to concatenate.
     * @return Concatenated form of [arrays].
     */
    private fun concat(vararg arrays: ByteArray): ByteArray {
        val out = ByteArrayOutputStream()
        arrays.forEach { out.write(it) }
        return out.toByteArray()
    }

    /**
     * Divide [buffer] by [divisor] and returns the remainder.
     *
     * @param buffer Byte array representation of a number in little endian.
     * @param divisor Number to divide [buffer] by.
     * @return Remainder of [buffer] divided by [divisor].
     */
    private fun byteArrayMod(buffer: ByteArray, divisor: Int): Int {
        // Check if MSB of buffer's MSB is set, if so
        // add byteArrayOf(0) to keep the sign positive
        val reversedBuffer = buffer.reversed().toByteArray()
        val m = BigInteger(
            (if (reversedBuffer[0].toInt() and 128 > 0) byteArrayOf(0)
            else byteArrayOf()) + reversedBuffer
        )
        return m.mod(divisor.toBigInteger()).toInt()
    }

    /**
     * Convert number [data] to byte array in little endian.
     *
     * @param data Number to convert.
     * @param size Byte size. Defaults to 8.
     * @return Byte array representation of number [data] in little endian.
     */
    private fun numberToByteArray(data: Number, size: Int = 8): ByteArray =
        ByteArray(size) { i -> (data.toLong() shr (i * 8)).toByte() }

    /**
     * Concatenate all the arguments and hash the result using the algorithm specified by [hashType].
     *
     * @param args Arguments to concatenate.
     * @return The hashed string.
     */
    private fun hashFunc(vararg args: ByteArray): ByteArray {
        val t: ByteArray = concat(*args)
        val md = MessageDigest.getInstance(hashType.acronym)
        return md.digest(t)
    }

    /**
     * First step of the algorithm. Fill up a buffer with
     * pseudorandom bytes derived from the password and salt
     * by computing repeatedly the hash function on a combination
     * of the password and the previous hash.
     *
     * @param buf A list of hashes as bytes.
     * @param cnt Used in a security proof (read the paper).
     * @param spaceCost The size of the buffer.
     * @return Counter used in a security proof (read the paper).
     */
    private fun expand(buf: ArrayList<ByteArray>, cnt: Int, spaceCost: Int): Int {
        var newcnt = cnt
        for (s in 1 until spaceCost) {
            buf.add(hashFunc(numberToByteArray(newcnt), buf[s - 1]))
            newcnt += 1
        }
        return newcnt
    }

    /**
     * Second step of the algorithm. Mix [timeCost] number
     * of times the pseudorandom bytes in the buffer. At each
     * step in the for loop, update the nth block to be
     * the hash of the n-1th block, the nth block, and [delta]
     * other blocks chosen at random from the buffer [buf].
     *
     * @param buf A list of hashes as bytes.
     * @param cnt Used in a security proof (read the paper).
     * @param delta Number of random blocks to mix with.
     * @param salt A user defined random value for security.
     * @param spaceCost The size of the buffer.
     * @param timeCost Number of rounds to mix.
     */
    private fun mix(buf: ArrayList<ByteArray>, cnt: Int, delta: Int, salt: ByteArray, spaceCost: Int, timeCost: Int) {
        var newcnt = cnt
        for (t in 0 until timeCost) {
            for (s in 0 until spaceCost) {
                buf[s] = hashFunc(numberToByteArray(newcnt), if (s == 0) extract(buf) else buf[s - 1], buf[s])
                newcnt += 1
                for (i in 0 until delta) {
                    val idxBlock = hashFunc(numberToByteArray(t), numberToByteArray(s), numberToByteArray(i))
                    val other = byteArrayMod(hashFunc(numberToByteArray(newcnt), salt, idxBlock), spaceCost)
                    newcnt += 1
                    buf[s] = hashFunc(numberToByteArray(newcnt), buf[s], buf[other])
                    newcnt += 1
                }
            }
        }
    }

    /**
     * Final step. Return the last value in the buffer.
     *
     * @param buf A list of hashes as bytes.
     * @return Last value of the buffer as bytes.
     */
    private fun extract(buf: ArrayList<ByteArray>): ByteArray {
        return buf.last()
    }

    /**
     * Main function that collects all the substeps. As
     * previously mentioned, first [expand], then [mix], and
     * finally [extract]. Note the result is returned as bytes,
     * for a more friendly function with default values
     * that returns a hex string, see the function [balloonHash].
     *
     * @param password The main string to hash.
     * @param salt A user defined random value for security.
     * @param spaceCost The size of the buffer.
     * @param timeCost Number of rounds to mix.
     * @param delta Number of random blocks to mix with. Defaults to 3.
     * @return A series of bytes, the hash.
     */
    fun balloon(password: String, salt: String, spaceCost: Int, timeCost: Int, delta: Int = 3): ByteArray {
        return _balloon(password, salt.toByteArray(), spaceCost, timeCost, delta)
    }

    /**
     * For internal use. Implements steps outlined in [balloon].
     *
     * @param password The main string to hash.
     * @param salt A user defined random value for security.
     * @param spaceCost The size of the buffer.
     * @param timeCost Number of rounds to mix.
     * @param delta Number of random blocks to mix with. Defaults to 3.
     * @return A series of bytes, the hash.
     */
    private fun _balloon(password: String, salt: ByteArray, spaceCost: Int, timeCost: Int, delta: Int = 3): ByteArray {
        val buf = ArrayList<ByteArray>()
        buf.add(hashFunc(numberToByteArray(0), password.toByteArray(), salt))
        val cnt = expand(buf, 1, spaceCost)
        mix(buf, cnt, delta, salt, spaceCost, timeCost)
        return extract(buf)
    }

    /**
     * A more friendly client function that just takes
     * a [password] and a [salt] and outputs the hash as a hex string.
     *
     * @param password The main string to hash.
     * @param salt A user defined random value for security.
     * @return The hash as hex.
     */
    fun balloonHash(password: String, salt: String): String {
        val delta = 4
        val timeCost = 20
        val spaceCost = 16
        return HexFormat.of().formatHex(balloon(password, salt, spaceCost, timeCost, delta = delta))
    }

    /**
     * M-core variant of the Balloon hashing algorithm. Note the result
     * is returned as bytes, for a more friendly function with default
     * values that returns a hex string, see the function [balloonMHash].
     *
     * @param password The main string to hash.
     * @param salt A user defined random value for security.
     * @param spaceCost The size of the buffer.
     * @param timeCost Number of rounds to mix.
     * @param parallelCost Number of concurrent instances.
     * @param delta Number of random blocks to mix with. Defaults to 3.
     * @return A series of bytes, the hash.
     */
    fun balloonM(password: String, salt: String, spaceCost: Int, timeCost: Int, parallelCost: Int, delta: Int = 3): ByteArray {
        val output = IntStream.range(0, parallelCost)
        .parallel()
        .mapToObj{p -> run {
            val parallelSalt = salt.toByteArray() + numberToByteArray(p+1)
            _balloon(password, parallelSalt, spaceCost, timeCost, delta)
        }}
        .reduce{a,b -> run {
            val buf = ByteArray(a.size)
            for (i in 0 until a.size) {
              buf[i] = (a[i].toUByte() xor b[i].toUByte()).toByte()
            }
            buf
        }}
        .orElseThrow {IllegalArgumentException()}

        return hashFunc(password.toByteArray(), salt.toByteArray(), output)
    }

    /**
     * A more friendly client function that just takes
     * a [password] and a [salt] and outputs the hash as a hex string.
     * This uses the M-core variant of the Balloon hashing algorithm.
     *
     * @param password The main string to hash.
     * @param salt A user defined random value for security.
     * @return The hash as hex.
     */
    fun balloonMHash(password: String, salt: String): String {
        val delta = 4
        val timeCost = 20
        val spaceCost = 16
        val parallelCost = 4
        return HexFormat.of().formatHex(balloonM(password, salt, spaceCost, timeCost, parallelCost, delta = delta))
    }

    /**
     * Verify that [hash] matches [password] when hashed with [salt], [spaceCost],
     * [timeCost], and [delta].
     *
     * @param hash The hash to check against.
     * @param password The password to verify.
     * @param salt A user defined random value for security.
     * @param spaceCost The size of the buffer.
     * @param timeCost Number of rounds to mix.
     * @param delta Number of random blocks to mix with. Defaults to 3.
     * @return true if password matches hash, otherwise false.
     */
    fun verify(hash: String, password: String, salt: String, spaceCost: Int, timeCost: Int, delta: Int = 3): Boolean {
        check(hash.length % 2 == 0) { "Must have an even length" }
        return MessageDigest.isEqual(balloon(password, salt, spaceCost, timeCost, delta), hash.decodeHex())
    }

    /**
     * Verify that [hash] matches [password] when hashed with [salt], [spaceCost],
     * [timeCost], [parallel cost], and [delta].
     * This uses the M-core variant of the Balloon hashing algorithm.
     *
     * @param hash The hash to check against.
     * @param password The password to verify.
     * @param salt A user defined random value for security.
     * @param spaceCost The size of the buffer.
     * @param timeCost Number of rounds to mix.
     * @param parallelCost Number of concurrent instances.
     * @param delta Number of random blocks to mix with. Defaults to 3.
     * @return true if password matches hash, otherwise false.
     */
    fun verifyM(hash: String, password: String, salt: String, spaceCost: Int, timeCost: Int, parallelCost: Int, delta: Int = 3): Boolean {
        check(hash.length % 2 == 0) { "Must have an even length" }
        return MessageDigest.isEqual(balloonM(password, salt, spaceCost, timeCost, parallelCost, delta), hash.decodeHex())
    }
}
